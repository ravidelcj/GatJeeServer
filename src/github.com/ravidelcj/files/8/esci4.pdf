#include<bits/stdc++.h>

using namespace std;

typedef pair<int,int> pii;
typedef pair<pii,pii> piil;
int arr[100005];
pii tree[200005];
piil lazy[200005];
pii precompute[100005];
int x;

//Function to return no of 5 and 2
//[2.5]
pair<int,int> calcNumber(long long a){

    pair<int,int> ans;
    int k=0,divisor=5;
    while(1){
        if(a%divisor==0){
            k++;
            a/=divisor;
        }else{
            break;
        }
    }
    ans.second=k;
    k=0;
    divisor=2;
    while(1){
        if(a%2==0){
            k++;
            a/=divisor;
        }else{
            break;
        }
    }
    ans.first=k;
    return ans;
}



pii calcNumber(long long a,long long n){

    pii ans=calcNumber(a);
    ans.first*=n;
    ans.second*=n;
    return ans;

}
void precomp(){

    precompute[0].first=0;
    precompute[0].second=0;
    precompute[1].first=0;
    precompute[1].second=0;
    for(int i=2;i<100001;i++){
        pii a=calcNumber(i);
        precompute[i].first=a.first+precompute[i-1].first;
        precompute[i].second=a.second+precompute[i-1].second;
    }

}

pair<int,int> build(int s,int e,int index){
    if(s>e){
        return make_pair(0, 0);
    }
    lazy[index]=make_pair(make_pair(0,0),make_pair(0, 0));
    if(s==e){
        pii ans;
        ans=calcNumber(arr[s]);
        tree[index]=ans;
        return ans;
    }

    int mid=(s+e)/2;
    pii ans1 = build(s, mid, 2*index+1);
    pii ans2 = build(mid+1, e, 2*index+2);
    tree[index]=make_pair(ans1.first+ans2.first, ans1.second+ans2.second);

    return tree[index];
}


pii query(int s,int e, int qs, int qe ,int index){
    if(s>e||e<qs||s>qe)
        return make_pair(0,0);


    if(lazy[index].second.first!=0||lazy[index].second.second!=0){
        tree[index].first=(lazy[index].second.first*(e-s+1));
        tree[index].first+=(precompute[e-s+1].first);
        tree[index].second=(lazy[index].second.second*(e-s+1));
        tree[index].second+=(precompute[e-s+1].second);
         if(s!=e){
            lazy[2*index+1].first.first=0;
            lazy[2*index+1].first.second=0;
            lazy[2*index+1].second.first=lazy[index].second.first;
            lazy[2*index+1].second.second=lazy[index].second.second;

            lazy[2*index+2].first.first=0;
            lazy[2*index+2].first.second=0;
            lazy[2*index+2].second.first=lazy[index].second.first;
            lazy[2*index+2].second.second=lazy[index].second.second;
        }
        lazy[index].second.first=0;
        lazy[index].second.second=0;
    }


    if(lazy[index].first.first!=0||lazy[index].first.second!=0){
        tree[index].first+=(lazy[index].first.first*(e-s+1));
        tree[index].second+=(lazy[index].first.second*(e-s+1));
        if(s!=e){
            lazy[2*index+1].first.first+=lazy[index].first.first;
            lazy[2*index+2].first.second+=lazy[index].first.second;
        }
        lazy[index].first.first=0;
        lazy[index].first.second=0;
    }
    if(s>=qs&&e<=qe){
        return tree[index];
    }

    int mid=(s+e)/2;

    pii ans1=query(s,mid,qs,qe,2*index+1);
    pii ans2=query(mid+1,e,qs,qe,2*index+2);
    return make_pair(ans1.first+ans2.first, ans1.second+ans2.second);
}

void update(int s,int e,int qs,int qe,int index){

    if(s>e||e<qs||s>qe)
        return ;

    if(lazy[index].second.first!=0||lazy[index].second.second!=0){
        tree[index].first=(lazy[index].second.first*(e-s+1));
        tree[index].first+=(precompute[e-s+1].first);
        tree[index].second=(lazy[index].second.second*(e-s+1));
        tree[index].second+=(precompute[e-s+1].second);
         if(s!=e){
            lazy[2*index+1].first.first=0;
            lazy[2*index+1].first.second=0;
            lazy[2*index+1].second.first+=lazy[index].second.first;
            lazy[2*index+1].second.second+=lazy[index].second.second;

            lazy[2*index+2].first.first=0;
            lazy[2*index+2].first.second=0;
            lazy[2*index+2].second.first+=lazy[index].second.first;
            lazy[2*index+2].second.second+=lazy[index].second.second;
        }
        lazy[index].second.first=0;
        lazy[index].second.second=0;
    }

    if(lazy[index].first.first!=0||lazy[index].first.second!=0){
        tree[index].first+=(lazy[index].first.first*(e-s+1));
        tree[index].second+=(lazy[index].first.second*(e-s+1));
        if(s!=e){
            lazy[2*index+1].first.first+=lazy[index].first.first;
            lazy[2*index+2].first.second+=lazy[index].first.second;
        }
        lazy[index].first.first=0;
        lazy[index].first.second=0;
    }

    if(s>=qs&&e<=qe){
        pii ans = calcNumber(x);
        tree[index].first+=(ans.first*(e-s+1));
        tree[index].second+=(ans.second*(e-s+1));
        //Setup lazy
        if(s!=e){
            lazy[2*index+1].first.first+=ans.first;
            lazy[2*index+1].first.second+=ans.second;

            lazy[2*index+2].first.first+=ans.first;
            lazy[2*index+2].first.second+=ans.second;
        }
        return;
    }

    int mid=(s+e)/2;

    update(s,mid,qs,qe,2*index+1);
    update(mid+1,e,qs, qe , 2*index+2);
    return;

}


void updateRange(int s,int e,int qs,int qe,int index){

     if(s>e||e<qs||s>qe)
        return ;

    if(lazy[index].second.first!=0||lazy[index].second.second!=0){
        tree[index].first=(lazy[index].second.first*(e-s+1));
        tree[index].first+=(precompute[e-s+1].first);
        tree[index].second=(lazy[index].second.second*(e-s+1));
        tree[index].second+=(precompute[e-s+1].second);
         if(s!=e){
            lazy[2*index+1].first.first=0;
            lazy[2*index+1].first.second=0;
            lazy[2*index+1].second.first=lazy[index].second.first;
            lazy[2*index+1].second.second=lazy[index].second.second;

            lazy[2*index+2].first.first=0;
            lazy[2*index+2].first.second=0;
            lazy[2*index+2].second.first=lazy[index].second.first;
            lazy[2*index+2].second.second=lazy[index].second.second;
        }
        lazy[index].second.first=0;
        lazy[index].second.second=0;
    }

    if(lazy[index].first.first!=0||lazy[index].first.second!=0){
        tree[index].first+=(lazy[index].first.first*(e-s+1));
        tree[index].second+=(lazy[index].first.second*(e-s+1));
        if(s!=e){
            lazy[2*index+1].first.first+=lazy[index].first.first;
            lazy[2*index+2].first.second+=lazy[index].first.second;
        }
        lazy[index].first.first=0;
        lazy[index].first.second=0;
    }

    if(s>=qs&&e<=qe){
        pii ans = calcNumber(x);
        tree[index].first=(ans.first*(e-s+1));
        tree[index].first+=(precompute[e-s+1].first);
        tree[index].second=(ans.second*(e-s+1));
        tree[index].second+=(precompute[e-s+1].second);
        //Setup lazy
        if(s!=e){
            lazy[2*index+1].first.first=0;
            lazy[2*index+1].first.second=0;
            lazy[2*index+1].second.first=ans.first;
            lazy[2*index+1].second.second=ans.second;

            lazy[2*index+2].first.first=0;
            lazy[2*index+2].first.second=0;
            lazy[2*index+2].second.first=ans.first;
            lazy[2*index+2].second.second=ans.second;
        }
        return;
    }

    int mid=(s+e)/2;

    updateRange(s,mid,qs,qe,2*index+1);
    updateRange(mid+1,e,qs, qe , 2*index+2);
    return;


}
int main(){

    ios_base::sync_with_stdio(false);
    precomp();
    int t;
    cin>>t;

    while(t--){
        int n,m;
        cin>>n>>m;
        for(int i=0;i<n;i++)
           cin>>arr[i];
        int counter=0;
        build(0,n-1,0);
        while(m--){
            int type,l,r;
            cin>>type>>l>>r;
            if(type==1){
            cin>>x;
                update(0,n-1,l-1,r-1,0);
            }else if(type==2){
            cin>>x;
                updateRange(0,n-1,l-1,r-1,0);
            }else{
                pii ans=query(0,n-1,l-1,r-1,0);
                counter+=(min(ans.first,ans.second));;
            }
        }
        cout<<counter<<endl;
    }
    return 0;
}
